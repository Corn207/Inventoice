using Application.Exceptions;
using Application.Interfaces.Repositories;
using Application.Interfaces.Repositories.Parameters;
using Domain.DTOs.Invoices;
using Domain.Entities;

namespace Application.Services;
public class InvoiceService
{
	private readonly IInvoiceRepository _invoiceRepository;
	private readonly IClientRepository _clientRepository;
	private readonly IProductRepository _productRepository;
	private readonly IExportReportRepository _exportReportRepository;

	public InvoiceService(
		IInvoiceRepository invoiceRepository,
		IClientRepository clientRepository,
		IProductRepository productRepository,
		IExportReportRepository exportReportRepository)
	{
		_invoiceRepository = invoiceRepository;
		_clientRepository = clientRepository;
		_productRepository = productRepository;
		_exportReportRepository = exportReportRepository;
	}

	public async Task<IEnumerable<InvoiceShort>> SearchAsync(
		string? product = null,
		string? client = null,
		string? author = null,
		InvoiceStatus? status = null,
		ushort pageNumber = 1,
		ushort pageSize = 15,
		DateTime? from = null,
		DateTime? to = null,
		bool isDescending = false)
	{
		var filter = new InvoiceFilterParameters(
			product ?? string.Empty,
			client ?? string.Empty,
			author ?? string.Empty,
			status);
		var pagination = new PaginationParameters(pageNumber, pageSize);
		var timeRange = new TimeRangeParameters(from ?? DateTime.MinValue, to ?? DateTime.MaxValue);

		var results = await _invoiceRepository.SearchAsync(filter, pagination, timeRange, isDescending);

		return results;
	}

	public async Task<Invoice?> GetAsync(string id)
	{
		return await _invoiceRepository.GetAsync(id);
	}

	public async Task<string> CreateAsync(InvoiceCreate create)
	{
		var createIds = create.ProductItems.Select(x => x.ProductId).ToArray();
		var products = await _productRepository
			.GetByIdsAsync(
				createIds,
				x => new
				{
					ProductId = x.Id!,
					Name = x.Name,
					Barcode = x.Barcode,
					StockCount = x.StockCount,
					SellingPrice = x.SellingPrice
				});

		if (products.Count != create.ProductItems.Length)
		{
			var nonExistingIds = createIds.Except(products.Select(x => x.ProductId));
			throw new InvalidIdException(nonExistingIds.ToArray());
		}

		var changes = products
			.Join(
				create.ProductItems,
				product => product.ProductId,
				create => create.ProductId,
				(product, create) => new
				{
					ProductId = product.ProductId,
					Name = product.Name,
					Barcode = product.Barcode,
					StockCount = product.StockCount,
					SellingPrice = product.SellingPrice,
					Quantity = create.Quantity
				})
			.ToArray();

		var outOfStockProductIds = changes
			.Where(x => x.StockCount < x.Quantity)
			.Select(x => x.ProductId)
			.ToArray();
		if (outOfStockProductIds.Length > 0)
		{
			throw new OutOfStockException(outOfStockProductIds);
		}

		var user = new User()
		{
			Id = "testId",
			Name = "Test User Name"
		};
		var userInfo = new UserInfo()
		{
			UserId = user.Id,
			Name = user.Name,
		};

		#region Creating export report
		var exportReportProductItems = changes
			.Select(x => new ExportReportProductItem()
			{
				ProductId = x.ProductId,
				Name = x.Name,
				Barcode = x.Barcode,
				Quantity = x.Quantity
			})
			.ToList();
		var exportReportEntity = new ExportReport()
		{
			Author = userInfo,
			ProductItems = exportReportProductItems,
			IsAutoGenerated = true,
			DateCreated = DateTime.Now
		};
		await _exportReportRepository.CreateAsync(exportReportEntity);
		#endregion

		#region Creating invoice
		var clientInfo = await _clientRepository
			.GetAsync(
				create.ClientId,
				x => new InvoiceClientInfo()
				{
					ClientId = x.Id!,
					Name = x.Name,
					PhoneNumber = x.PhoneNumber,
				});
		var invoiceProductItems = changes
			.Select(x => new InvoiceProductItem()
			{
				ProductId = x.ProductId,
				Name = x.Name,
				Barcode = x.Barcode,
				UnitPrice = x.SellingPrice,
				Quantity = x.Quantity
			})
			.ToList();
		var invoiceEntity = new Invoice()
		{
			Author = userInfo,
			Client = clientInfo,
			ExportReportId = exportReportEntity.Id!,
			ProductItems = invoiceProductItems,
			PaidAmount = create.PaidAmount ?? 0,
			DateCreated = DateTime.Now,
			DatePaid = create.PaidAmount is not null ? DateTime.Now : null,
		};
		#endregion

		var tasks = changes
			.Select(x => _productRepository.UpdateAsync(x.ProductId, x => x.StockCount, x.StockCount - x.Quantity))
			.Append(_invoiceRepository.CreateAsync(invoiceEntity));
		await Task.WhenAll(tasks);

		return invoiceEntity.Id!;
	}

	public async Task DeleteAsync(string id)
	{
		try
		{
			await _invoiceRepository.SoftDeleteAsync(id);
		}
		catch (KeyNotFoundException)
		{
			throw;
		}
		catch (Exception)
		{
			throw;
		}
	}

	public async Task CancelAsync(string id)
	{
		var invoice = await _invoiceRepository.GetAsync(
			id,
			x => new
			{
				Id = x.Id,
				ExportReportId = x.ExportReportId,
				ProductItems = x.ProductItems.Select(i => new
				{
					ProductId = i.ProductId,
					Quantity = i.Quantity
				}).ToArray()
			},
			x => x.DateCancelled == null) ?? throw new KeyNotFoundException("Id was not found or cancelled or deleted.");

		var products = await _productRepository.GetByIdsAsync(
			invoice.ProductItems.Select(x => x.ProductId),
			x => new
			{
				Id = x.Id!,
				StockCount = x.StockCount
			});

		var timeCancelled = DateTime.Now;
		var tasks = products
			.Join(
				invoice.ProductItems,
				product => product.Id,
				invoice => invoice.ProductId,
				(product, invoice) => _productRepository.UpdateAsync(product.Id, x => x.StockCount, product.StockCount + invoice.Quantity))
			.Append(_exportReportRepository.UpdateAsync(invoice.ExportReportId, x => x.DateCancelled, timeCancelled))
			.Append(_invoiceRepository.UpdateAsync(id, x => x.DateCancelled, timeCancelled));

		try
		{
			await Task.WhenAll(tasks);
		}
		catch (KeyNotFoundException)
		{
		}
	}

	public async Task PayAsync(string id, uint amount)
	{
		try
		{
			await _invoiceRepository.UpdateAsync(
				id,
				x => x.DatePaid, DateTime.Now,
				x => x.PaidAmount, amount,
				x => x.DatePaid == null && x.DateCancelled == null);
		}
		catch (KeyNotFoundException)
		{
			throw;
		}
	}
}
